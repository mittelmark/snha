#' \name{snha-package}
#' \alias{snha-package}
#' \title{ snha package - association chain graphs from correlation networks}
#' \description{ The snha package can be used to construct association chain graphs 
#'    based on the St. Nicolas House algorithm as described in Groth et. 2019.}
#' \details{The package provides the following functions:
#' Function for graph generation from data:
#' \describe{
#' \item{\link[snha:snha]{snha(data)}}{creates and returns a new snha graph}
#' }
#' S3 methods for snha graphs:
#' \describe{
#' \item{\link[snha:plot.snha]{plot.snha(snhaobject)}}{plots a snha graph}
#' \item{\link[snha:as.list.snha]{as.list.snha(snhaobject)}}{return a list
#'    representation of a snha graph object}
#' }
#' Utility functions:
#' \describe{
#' \item{\link[snha:snha.getChains]{snha.getChains(snhagraph)}}{returns the chains found by the algorithm as matrix}
#' \item{\link[snha:snha.layout]{snha.layout(g)}}{calculate layout coordinates for the given graph or adjacency matrix}
#' \item{\link[snha:snha.ll]{snha.ll(g,chain)}}{calculate log-likelihood for the given chain of the snha graph}
#' \item{\link[snha:snha.mplot]{snha.mplot(mt)}}{plots an adjacency matrix using the plotting facilities of the snha package}
#' \item{\link[snha:snha.rsquare]{snha.rsquare(data,g)}}{for given data and graph or adjacency matrix calculate 
#'    linear model r-square value}
#' }
#' }
#' \examples{
#' library(MASS)
#' data(birthwt)
#' as=snha(birthwt[,-1])
#' ls(as)
#' }
#' \author{Detlef Groth <dgroth@uni-potsdam.de>}
#' \references{
#' \itemize{
#'    \item Groth, D., Scheffler, C., & Hermanussen, M. (2019). 
#'    Body height in stunted Indonesian children depends directly on parental education and not 
#'     via a nutrition mediated pathway - 
#'     Evidence from tracing association chains by St. Nicolas House Analysis. 
#'     \emph{Anthropologischer Anzeiger}, 76 No. 5 (2019), p. 445 - 451. \url{https://doi.org/10.1127/anthranz/2019/1027}
#'    \item Hermanussen, M., Assmann, C. und Groth, D. (2021).
#'    Chain Reversion for Detecting Associations in Interacting Variables - St. Nicolas House Analysis.
#'    \emph{International Journal of Environmental Research and Public Health}. 18, 4 (2021). \url{https://doi.org/10.3390/ijerph18041741}.
#'    \item Novine, M., Mattsson, C. C., & Groth, D. (2021).
#'    Network reconstruction based on synthetic data generated by a Monte Carlo approach. \emph{Human Biology and Public Health}, 3:26. \url{ https://doi.org/10.52905/hbph2021.3.26}
#' }
#' }
""

#' \name{snha}
#' \alias{snha}
#' \title{Initialize a snha object with data.}
#' \description{
#'     The main entry function to initialize a snha object with data where
#'     variables are in columns and items are in rows
#' }
#' \usage{ snha(data,alpha=0.05,method='pearson',threshold=0.01,check.singles=FALSE,prob=FALSE,prob.threshold=0.2,prob.n=25)}
#' \arguments{
#' \item{data}{a dataframe where network nodes are the rownames and data
#'             variables are in the columns.}
#' \item{alpha}{confidence threshold for p-value edge cutting after all chains
#'              were generated, default: 0.05.}
#' \item{method}{method to calculate correlation/association values, can be
#'               pearson, spearman or kendall, default: 'pearson'.}
#' \item{threshold}{R-squared correlation coefficient threshold for which
#'           r-square values should be used for chain generation, r=0.1 is r-square of
#'           0.01, default: 0.01.}
#' \item{check.singles}{should isolated nodes connected with sufficent high R^2
#'           and significance, default: FALSE.}
#' \item{prob}{should be probabilities computed for each edge using
#'          bootstrapping. Only in this case the parameters starting with prob are used,
#'          default: FALSE}
#' \item{prob.threshold}{threshold to set an edge, a value of 0.5 means, that
#'          the edge must be found in 50\% of all samplings, default: 0.2}
#' \item{prob.n}{number of boostrap samples to be taken, default: 25}
#' }
#' \keyword{network, correlation}
#' \value{A snha graph data object with the fields theta for the adjacency
#'       matrix, sigma for the correlation matrix, chains for the association chains
#'       and data representing the input data.}
#' \examples{
#' data(swiss)
#' sw.g=snha(swiss,method='spearman')
#' # what objects are there?
#' ls(sw.g)
#' sw.g$theta
#' round(sw.g$sigma,2)
#' sw.g=snha(swiss,method='spearman',check.singles=TRUE,prob=TRUE)
#' sw.g$theta
#' sw.g$probablities
#' }
#' \seealso{ \link[snha:plot.snha]{plot.snha}}
#' 


snha <- function (data,alpha=0.05,method='pearson',threshold=0.01,
                     check.singles=FALSE,
                     prob=FALSE,prob.threshold=0.2,prob.n=25) {
    if (prob) {
        # check for correlation matrix
        if (nrow(data)==ncol(data) &  
                length(which(colnames(cor(data))==rownames(cor(data)))) == nrow(data)) {
                    stop("only data matrices, not correlation matrices, can be used for bootstrapping graphs")
        }

        as=snha(data,alpha=alpha,method=method,threshold=threshold,
                   check.singles=check.singles,prob=FALSE)
        rand.prob=as$theta
        rand.prob[]=0
        for (i in 1:prob.n) {
            sam=sample(1:nrow(data),nrow(data),replace=TRUE)
            asi=snha(data[sam,],alpha=alpha,method=method,threshold=threshold,
                        check.singles=check.singles,prob=FALSE)
            if (i == 1) {
                as$probabilities=asi$theta
            } else {
                as$probabilities=as$probabilities+asi$theta
                #recover()
            }
            rand.data=data
            for (i in 1:ncol(data)) {
                rand.data[,i]=sample(data[,i])
            }
            asr=snha(rand.data,alpha=alpha,method=method,threshold=threshold,
                        check.singles=check.singles,prob=FALSE)
            rand.prob=rand.prob+asr$theta
        }
        as$probabilities=as$probabilities/prob.n
        rand.prob=as.vector(rand.prob)/prob.n
        as$rand.probabilities=as$probabilities
        as$rand.probabilities[]=rand.prob
        as$theta[as$probabilities>=prob.threshold]=1
        as$theta[as$probabilities<prob.threshold]=0
        as$p.values=as$theta
        vprob=as.vector(as$probabilities)
        as$p.values[]=unlist(lapply(vprob,function (x) 1-length(which(x>rand.prob))/length(rand.prob)))
    } else {
        as=Asgp$data2chainGraph(data,alpha=alpha,method=method,threshold=threshold)
        if (check.singles) {
            cmt=as$sigma
            #cor(data,method=method,use='pairwise.complete.obs')
            if (method!= "kendall") {
                cmt=cmt^2
            } else {
                cmt=abs(cmt)
            }
            diag(cmt)=0
            idx=which(apply(as$theta,1,sum)==0) 
            for (i in idx) {
                if (max(cmt[i,])>threshold) {
                    j=which(max(cmt[i,])==cmt[i,])
                    options(warn=-1)
                    if (cor.test(data[,i],data[,j])$p.value<alpha) {
                        as$theta[i,j]=0.5
                        as$theta[j,i]=0.5
                    }
                    options(warn=0)
                }
            }
        }
        as$probabilities=as$theta
    }
    as=ReduceChains(as)
    class(as)='snha'
    return(as)
}
ReduceChains = function (g) {
    ichains=c()
    chs=sort(names(g$chains))
    for (cho in chs) {
        if (length(g$chains[[cho]]) == 1) {
            next
        }
        co=g$chains[[cho]]
        for (chi in chs) {
            if (length(g$chains[[chi]])==1) {
                next
                
            }
            if (length(g$chains[[cho]]) == 1) {
                next
            }

            if (chi == cho) { next }
            ci=g$chains[[chi]]
            if (length(co)> length(ci)) { next }
            if (length(co) == length(ci)) {
                if (all(co==ci) | all(co==rev(ci))) {
                    ichains=c(ichains,chi)
                    g$chains[[chi]] = ''
                }
            } else {
                cop=paste(co,collapse='')
                cipo=paste(ci,collapse='')
                cipr=paste(rev(ci),collapse='')
                if (grepl(cop,cipo,fixed=TRUE)) {
                    ichains=c(ichains,cho)
                    g$chains[[cho]] = ''

                } else if (grepl(cop,cipr,fixed=TRUE)) {
                    ichains=c(ichains,cho)
                    g$chains[[cho]] = ''
                }
            }
            
        }
    }
    for (ch in ichains) {
        g$chains[[ch]]=NULL
    }
    return(g)
}

