---
title: "Tutorial on the snha package"
shorttitle: "snha package tutorial"
author: Detlef Groth, University of Potsdam, Germany
date: 2023-03-02
abstract: >
    The *snha* package provides an easy to use interface to apply the St.
    Nicolas House Algorithm which traces associations chains between
    interactiving variables. The algorithm was described recently by Groth et.
    al. (2019) @Groth2019 and more detailed by Hermanussen et. al. (2021) @Hermanussen2021.
    In this package vignette the basic workflow for analyzing your and raw data and as well for 
    analysing precomputed correlation matrices is demonstrated.
bibliography: bibliography.bib
csl: nature-biotechnology.csl

output: function () { rmarkdown::html_vignette(toc=TRUE,css="style.css") }
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Tutorial on the snha package}
  %\usepackage[utf8]{inputenc}
---

## Introduction

The package `snha` explores interacting variables by searching association
chains, so where correlation coefficient drop in a regular order between the
nodes. The package can be easily used by calling the function `snha` with
your data, where the columns must be your variables. The return value is an
object of class `snha` which has a plot function. The detailed analysis can be
inspected by looking at the internal variables of this object. Below a minimal
analysis for the `birthwt` data from the _MASS_ R package. The variables are:

* _age_ - mother's age in years.
* _lwt_ - mother's weight in pounds at last menstrual period.
* _race_ - mother's race (1 = white, 2 = black, 3 = other).
* _smoke_ - smoking status during pregnancy (0 = no, 1 = yes).
* _ptl_ - number of previous premature labours.
* _ht_ - history of hypertension (0 = no, 1 = yes).
* _ui_ - presence of uterine irritability (0 = no, 1 = yes).
* _ftv_ - number of physician visits during the first trimester.
* _bwt_ - birth weight of child in grams.

Let's start with the data preparation. For illustrative purposes we add
a random data vector as well:

```{r label=ddataprep}
set.seed(125)
# retrieve some data
library(MASS)
data(birthwt)
birthwt$low=NULL 
# removeed column for the low indicator says 
# if a child has low birtwt
rnd=round(rnorm(nrow(birthwt),mean=10,sd=2),2)
# rnd just contains random data
birthwt=cbind(birthwt,rnd=rnd) # adding a random var
head(birthwt)
```

OK, we are ready to go, we added the random data column `rnd` and removed the
redundant column `low` which indicated low birth weight, for this we have no
the `bwt` column in the data set.

Let's now first start with a PCA and then with our SNHA method where we use
Spearman correlation which is more robust against outliers than Pearson
correlation, we set the p-value threshold, _alpha_ to 0.1 as the algorithm id
very resistant against the detection of spurious correlations.

```{r label=plotsnha, fig.width=10,fig.height=5,fig.cap="Birth weight data variable interactions"}
par(mfrow=c(1,2),mai=c(0.8,0.8,0.1,0.2))
library(snha)
# retrieve some data
pca=prcomp(t(scale(birthwt)))
summary(pca)
plot(pca$x[,1:2],xlab='PC1', ylab='PC2',pch=19,cex=5,col='salmon')
text(pca$x[,1:2],colnames(birthwt))
as=snha(birthwt,method="spearman",alpha=0.1) 
par(mai=c(0.8,0.2,0.1,0.2))
plot(as,layout="sam",vertex.size=7,lwd=3,edge.width=3)
box()
```

As you can see the variables in this simple graphs show immediately logical
interactions, the birth weight is positively associated to mothers last weight,
and negatively to smoking, premature labours and uterine irritability, white
people smoke more and white mothers visit more often physicians ... The older
the mother the more visits at physicians and hypertension is positively
associated with weight of the mother.

What are the r-square values, prediction power for every node based on linear
models and what are the connections:

```{r}
round(snha_rsquare(as),2)
as$theta
```

It can be seen that the overall strength of the association is very small,
largest r-square value is 0.18 for smoke, but still the analysis show reasonable
results without having the necessity of finding the right threshold.


## Decathlon data

Here is an other example where we analyze the relationship between the different
decathlon elements with athletes taking part in the 1988 Olympics and which were
above 7000 points. We perform the St. Nicolas House Algorithm analysis and
later check the average R-square values for the each node.

```{r label=dec,fig.width=9,fig.height=6,fig.cap="Decathlon Data 1988"}
data(decathlon88)
head(decathlon88)
A=snha(decathlon88,method="spearman",alpha=0.1)
cols=rep("salmon",10)
cols[names(A$data) %in% c("jave","shot","disc","pole")]="skyblue"
plot(A,layout="sam",vertex.color=cols,vertex.size=8,cex=1.1,edge.width=5)
snha_rsquare(A)
mn=mean(snha_rsquare(A))
title(paste("R-square = ",round(mn,2)))
```

As you can see the variables nicely separates between disciplines related to
the upper part of the body (blue) and disciplines where the legs do most of the
work (salmon). The mostly hated 1500m run is negatively associated to the
throwing disciplines. The running distances are building a chain
_100-400-1500m_ as expected. As you can see the variables are just in their logical order. 

## Swiss dataset example

Let's finish with an other data set, the `swiss` data which are available in
every R installation. Here we try out both the correlation methods, Spearman
and Pearson correlation. We use the function `snha_layout` to determine
a layout matrix which we will then reuse for both plots.

```{r label=plot,fig.width=10,fig.height=5,fig.cap="Swiss data associations"}
library(snha)
data(swiss)
head(swiss,4)
colnames(swiss)=abbreviate(colnames(swiss))
head(swiss,4)
par(mfrow=c(1,2))
options(warn=-1)
as=snha(swiss,method="pearson")
lay = snha_layout(as,mode="sam")
plot(as,layout=lay,vertex.size=8,main="Pearson")
as=snha(swiss,method="spearman")
plot(as,layout=lay,vertex.size=8,main="Spearman")
```

Here is the resulting adjacency matrix:

```{r label=theta,results='asis'}
knitr::kable(as$theta)
```

As you can see the structure remains the same, but Pearson correlation shows
more edges, we should check if the data are normally distributed.
Without playing around with some parameters or thresholds we get immediately the general
associations between the data.  

```{r, result="asis"}
mtest = function (x) { return(shapiro.test(x)$p.value)  }
df=data.frame(orig=round(apply(swiss,2,mtest),3))
df=cbind(df,log2=round(apply(log2(swiss),2,mtest),3))
knitr::kable(df)
```

As you can see, both with the original data and as well with the log-normalized
data the Shapiro-Wilk test has a few significant entries, so we reject the
Null-hypothesis that these data are coming from a normal distribution. So for
our example using the `swiss` data we should very likely prefer using the Spearman correlation. 

## Creating your own data

In order to test the algorithm there is as well in the package a function which
allows you to generate data for directed and undirected graphs, either using
the given adjacency matrix as precision matrix or using a Monte Carlo
simulation as described by @Novine21. Here an example:

```{r werner}
W=matrix(0,nrow=6,ncol=6,dimnames=list(LETTERS[1:6],LETTERS[1:6]))
W[1:2,3]=1
W[3,4]=1
W[4,5:6]=1
W[5,6]=1
W
```

For such an adjacency matrix we can create data like this:

```{r}
data=snha_graph2data(W)
dim(data)
round(cor(t(data)),2)
```

As you can see the correlations follow the given graph, we can as well plot
these for better illustration:

```{r label=wplot,fig.width=8,fig.height=3,out.width=900}
par(mfrow=c(1,3),mai=rep(0.2,4))
plot.snha(W)
plot.snha(cor(t(data)),type="cor")
plot.snha(snha(t(data)))
```


## Installation

As long as the package is not yet on the CRAN repository the package can be
usually installed using the submitted `tar.gz` archive with the following
commands:

```
library(tcltk)
pkgname=tclvalue(tkgetOpenFile(
    filetypes="{{Tar.gz files} {*.tar.gz}} {{All files} {*.*}}"))
if (pkgname != "") {
    install.packages(pkgname,repos=NULL)
}
```

It is as well possible to install the latest version directly from the Github
repository like this:

```
library(remotes)
remotes::install_github("https://github.com/mittelmark/snha")

```

Thereafter you can check the installation like this:

```
library(snha)
citation("snha")
```


## Concept

Analyzing multivariate data is often done using visualization of pairwise
correlations, principal component analysis or multidimensional scaling are
typical methods in this area. The snha package provides an alternative
approach, by uncovering ordered sequences of correlation coefficients which
can be reversed [@Groth2019] [@Hermanussen2021]. Existing chains are translated
into edges between the variables here taken as nodes of a graph. The graph can
be then visualized and the major relations between the variables are visible.

The basic assumption of the method is the assumption that variables
correlations coefficients between two variables were one influences the other
are larger than those of secondary associations. So for instance if we assume
that a variable A influences a variable B, and B influences C, it can be
assumed, that _r(AB)_ > _r(AC)_ and that in the opposite direction _r(CB)_ > _r(CA)_.
The algorithm provided in the snha package uncovers such association chains
where the order of correlation coefficient can be reversed. The advantage of
the method is that there is only a very limited requirement for choosing
thresholds for instance for the p-value or for the correlation coefficient.
The reason is that the existence of such association chains with the correct
ordering of three or more nodes is much less likely to exists by accident then
significant pairwise correlations.

In the following we will first illustrate the concept on a simple hypothetical
association chain and thereafter show exemplarily the analysis on two well
known example datasets.

## Simple association chain

Let's assume we have a simple association chain where a variable A is
influencing a variable B, B is influencing a variable C and C is influencing
variable D. 

```{r label=start,fig.width=6,fig.height=1.7,fig.cap="An association chain"}
par(mai=c(0.1,0.1,0.1,0.0))
plot(1,xlab="",ylab="",axes=FALSE,type="n",xlim=c(0.5,4.5),ylim=c(0.8,1.2))
arrows(1:3,rep(1,3),1:3+0.8,rep(1,3),lwd=3,length=0.1)
points(1:4,rep(1,4),pch=19,col="salmon",cex=6)
text(1:4,1,LETTERS[1:4],cex=2)
```

In this situation we can assume that, due to the omnipresent noise in such
situation, the correlations of directly interacting variables is higher in
comparison to variables only connected only via other variables. Let's assume
for simplicity reasons, that the correlation between directly connected
variables drops down from r=0.7 to around r=0.5 for secondary connected
variables and r=0.3 for tertiary connected variables. So a possible correlation
matrix could look like this:


```{r result='asis'}
C=matrix(c(1,0.7,0.5,0.3,
           0.7,1,0.7,0.5,
           0.5,0.7,1,0.7,
           0.3,0.5,0.7,1),
           nrow=4,byrow=TRUE)
rownames(C)=colnames(C)=LETTERS[1:4]           
knitr::kable(C)
```

Let's now add a little bit of noise and visualize the pairwise correlations
using the plot function of the `snha` package.

```{r label=corplot,fig.width=6,fig.height=3,fig.cap="Visualization of correlation matrix sigma and the adjacency matrix theta"}
set.seed(123)
par(mfrow=c(1,2),mai=c(0.1,0.1,0.1,0.1))
C=C+rnorm(length(C),mean=0,sd=0.1)
C[lower.tri(C)]=t(C)[lower.tri(C)]
diag(C)=1
as=snha(C)
round(as$sigma,3)
plot(as,type="corplot")
as$theta
plot(as)
```

As we can see, the correlations are now slightly altered. A simple
*r* threshold mechanism, for instance taking only correlation larger than 0.5
into consideration would as well have false positive edges like between the nodes B and D. The
function `snha` takes as input either a correlation matrix or a data matrix
or data.frame and tries to find such association chains. The association chain
is stored in the internal object theta and can be visualized using the default
plot command.


## Summary

Here are the functions to be used by the normal user of the package:

* _snha_ - create a snha graph object
* _plot_ - plot a snha graph object
* _as.list_ - create a list out of a snha graph object, ready to write for
  instance into an Excel file  
* *snha_get_chains* - get the actual chains which were found and which build the graph
* *snha_graph2data* - generate for a given adjacency matrix some data    
* *snha_rsquare* - get r-square values for the nodes based on linear model to have 
  a qualitative measure for the graph prediction. 


The snha graph object contains a few variables which might be of interest for the user:

* _alpha_ - the chosen p-value threshold
* _chains_ - the found association chains
* _data_ - the input data
* _method_ - the correlation method
* _p-values_ the pairwise p-values
* _probabilities_ - in case of bootstrapping the proportion how often a chain was found
* _theta_ - the adjacency matrix for the nodes / variables

## Build information

The package was build using `r R.version.string` on `r  R.version$platform` using snha package `r packageVersion('snha')`.

```{r}
print(sessionInfo())
```

## References


